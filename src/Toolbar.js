L.Toolbar = L.Class.extend({
	includes: [L.Mixin.Events],

	options: {
		buttonClassNamePrefix: 'leaflet-draw-button-',
		toolbarContainerClassName: 'leaflet-draw-section',
		toolbarClassName: 'leaflet-draw-toolbar leaflet-bar',
		toolbarClassNamePrefix: 'leaflet-draw-toolbar-',
		actionsClassName: 'leaflet-draw-actions',
		actionsClassNamePrefix: 'leaflet-draw-actions-'
	},

	_css: {
		toolbar: {
			container: function() {
				return this.options.toolbarContainerClassName;
			},
			css: function() {
				return this.options.toolbarClassName;
			},
			prefix: function(value) {
				return this.options.toolbarClassNamePrefix + value;
			}
		},
		actions: {
			css: function() {
				return this.options.actionsClassName;
			},
			prefix: function(value) {
				return this.options.actionsClassNamePrefix + value;
			}
		},
		button: {
			prefix: function(value) {
				return this.options.buttonClassNamePrefix + value;
			}
		}
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._modes = {};
		this._actionButtons = [];
		this._activeMode = null;

		this._css.toolbar.options = this.options;
		this._css.actions.options = this.options;
		this._css.button.options = this.options;
	},

	enabled: function () {
		return this._activeMode !== null;
	},

	disable: function () {
		if (!this.enabled()) { return; }

		this._activeMode.handler.disable();
	},

	addToolbar: function (map) {
		var container = L.DomUtil.create('div', this._css.toolbar.container()),
			buttonIndex = 0,
			modeHandlers = this.getModeHandlers(map),
			i;

		this._toolbarContainer = L.DomUtil.create('div', this._css.toolbar.css());
		this._map = map;

		for (i = 0; i < modeHandlers.length; i++) {
			if (modeHandlers[i].enabled) {
				this._initModeHandler(
					modeHandlers[i].handler,
					this._toolbarContainer,
					modeHandlers[i].className,
					buttonIndex++,
					modeHandlers[i].title
				);
			}
		}

		// if no buttons were added, do not add the toolbar
		if (!buttonIndex) {
			return;
		}

		// Save button index of the last button, -1 as we would have ++ after the last button
		this._lastButtonIndex = --buttonIndex;

		// Create empty actions part of the toolbar
		this._actionsContainer = L.DomUtil.create('ul', this._css.actions.css());

		// Add draw and cancel containers to the control container
		container.appendChild(this._toolbarContainer);
		container.appendChild(this._actionsContainer);

		return container;
	},

	removeToolbar: function () {
		// Dispose each handler
		for (var handlerId in this._modes) {
			if (this._modes.hasOwnProperty(handlerId)) {
				// Unbind handler button
				this._disposeButton(
					this._modes[handlerId].button,
					this._modes[handlerId].handler.enable,
					this._modes[handlerId].handler
				);

				// Make sure is disabled
				this._modes[handlerId].handler.disable();

				// Unbind handler
				this._modes[handlerId].handler
					.off('enabled', this._handlerActivated, this)
					.off('disabled', this._handlerDeactivated, this);
			}
		}
		this._modes = {};

		// Dispose the actions toolbar
		for (var i = 0, l = this._actionButtons.length; i < l; i++) {
			this._disposeButton(
				this._actionButtons[i].button,
				this._actionButtons[i].callback,
				this
			);
		}
		this._actionButtons = [];
		this._actionsContainer = null;
	},

	_initModeHandler: function (handler, container, cssClassName, buttonIndex, buttonTitle) {
		var type = handler.type;

		this._modes[type] = {};

		this._modes[type].handler = handler;

		this._modes[type].button = this._createButton({
			type: type,
			title: buttonTitle,
			container: container,
			callback: this._modes[type].handler.enable,
			context: this._modes[type].handler,
			cssClassName: cssClassName,
			type: type
		});

		this._modes[type].buttonIndex = buttonIndex;

		this._modes[type].handler
			.on('enabled', this._handlerActivated, this)
			.on('disabled', this._handlerDeactivated, this);
	},

	_createButton: function (options) {
		var buttonCssClasses = this._css.button.prefix(options.type) + (options.cssClassName ? ' ' + options.cssClassName : ''),
			link = L.DomUtil.create('a', buttonCssClasses, options.container);
		link.href = '#';

		if (options.text) {
			link.innerHTML = options.text;
		}

		if (options.title) {
			link.title = options.title;
		}

		L.DomEvent
			.on(link, 'click', L.DomEvent.stopPropagation)
			.on(link, 'mousedown', L.DomEvent.stopPropagation)
			.on(link, 'dblclick', L.DomEvent.stopPropagation)
			.on(link, 'click', L.DomEvent.preventDefault)
			.on(link, 'click', options.callback, options.context);
			// .on(link, 'click', function() {
			// 	options.callback.apply(options.context, {
			// 		link: link
			// 	});
			// });

		return link;
	},

	_disposeButton: function (button, callback) {
		L.DomEvent
			.off(button, 'click', L.DomEvent.stopPropagation)
			.off(button, 'mousedown', L.DomEvent.stopPropagation)
			.off(button, 'dblclick', L.DomEvent.stopPropagation)
			.off(button, 'click', L.DomEvent.preventDefault)
			.off(button, 'click', callback);
	},

	_handlerActivated: function (e) {
		// Disable active mode (if present)
		this.disable();

		// Cache new active feature
		this._activeMode = this._modes[e.handler];

		L.DomUtil.addClass(this._activeMode.button, this._css.toolbar.prefix('button-enabled'));

		this._showActionsToolbar();

		this.fire('enable');
	},

	_handlerDeactivated: function () {
		this._hideActionsToolbar();

		L.DomUtil.removeClass(this._activeMode.button, this._css.toolbar.prefix('button-enabled'));

		this._activeMode = null;

		this.fire('disable');
	},

	_createActions: function (handler) {
		var container = this._actionsContainer,
			buttons = this.getActions(handler),
			l = buttons.length,
			li, di, dl, button, buttonAction;

		container.className = this._css.actions.css() + ' ' + this._css.actions.prefix(handler.type);

		// Dispose the actions toolbar (todo: dispose only not used buttons)
		for (di = 0, dl = this._actionButtons.length; di < dl; di++) {
			this._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);
		}
		this._actionButtons = [];

		// Remove all old buttons
		while (container.firstChild) {
			container.removeChild(container.firstChild);
		}

		for (var i = 0; i < l; i++) {
			if ('enabled' in buttons[i] && !buttons[i].enabled) {
				continue;
			}

			buttonAction = handler.type + (buttons[i].type ? '-' + buttons[i].type : '');
			li = L.DomUtil.create('li', this._css.actions.prefix('button') + ' ' + this._css.actions.prefix(buttonAction), container);

			button = this._createButton({
				title: buttons[i].title,
				text: buttons[i].text,
				container: li,
				callback: buttons[i].callback,
				context: buttons[i].context,
				type: buttonAction
			});

			this._actionButtons.push({
				button: button,
				callback: buttons[i].callback
			});
		}
	},

	_showActionsToolbar: function () {
		var buttonIndex = this._activeMode.buttonIndex,
			lastButtonIndex = this._lastButtonIndex,
			toolbarPosition = this._activeMode.button.offsetTop - 1;

		// Recreate action buttons on every click
		this._createActions(this._activeMode.handler);

		// Correctly position the cancel button
		this._actionsContainer.style.top = toolbarPosition + 'px';

		if (buttonIndex === 0) {
			L.DomUtil.addClass(this._toolbarContainer, this._css.toolbar.prefix('notop'));
			L.DomUtil.addClass(this._actionsContainer, this._css.actions.prefix('top'));
		}

		if (buttonIndex === lastButtonIndex) {
			L.DomUtil.addClass(this._toolbarContainer, this._css.toolbar.prefix('nobottom'));
			L.DomUtil.addClass(this._actionsContainer, this._css.actions.prefix('bottom'));
		}

		this._actionsContainer.style.display = 'block';
	},

	_hideActionsToolbar: function () {
		this._actionsContainer.style.display = 'none';

		L.DomUtil.removeClass(this._toolbarContainer, this._css.toolbar.prefix('notop'));
		L.DomUtil.removeClass(this._toolbarContainer, this._css.toolbar.prefix('nobottom'));
		L.DomUtil.removeClass(this._actionsContainer, this._css.actions.prefix('top'));
		L.DomUtil.removeClass(this._actionsContainer, this._css.actions.prefix('bottom'));
	}
});
